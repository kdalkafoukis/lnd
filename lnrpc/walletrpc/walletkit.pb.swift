// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: walletrpc/walletkit.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Walletrpc_AddressType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case witnessPubkeyHash // = 1
  case nestedWitnessPubkeyHash // = 2
  case hybridNestedWitnessPubkeyHash // = 3
  case taprootPubkey // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .witnessPubkeyHash
    case 2: self = .nestedWitnessPubkeyHash
    case 3: self = .hybridNestedWitnessPubkeyHash
    case 4: self = .taprootPubkey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .witnessPubkeyHash: return 1
    case .nestedWitnessPubkeyHash: return 2
    case .hybridNestedWitnessPubkeyHash: return 3
    case .taprootPubkey: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Walletrpc_AddressType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Walletrpc_AddressType] = [
    .unknown,
    .witnessPubkeyHash,
    .nestedWitnessPubkeyHash,
    .hybridNestedWitnessPubkeyHash,
    .taprootPubkey,
  ]
}

#endif  // swift(>=4.2)

enum Walletrpc_WitnessType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownWitness // = 0

  ///
  ///A witness that allows us to spend the output of a commitment transaction
  ///after a relative lock-time lockout.
  case commitmentTimeLock // = 1

  ///
  ///A witness that allows us to spend a settled no-delay output immediately on a
  ///counterparty's commitment transaction.
  case commitmentNoDelay // = 2

  ///
  ///A witness that allows us to sweep the settled output of a malicious
  ///counterparty's who broadcasts a revoked commitment transaction.
  case commitmentRevoke // = 3

  ///
  ///A witness that allows us to sweep an HTLC which we offered to the remote
  ///party in the case that they broadcast a revoked commitment state.
  case htlcOfferedRevoke // = 4

  ///
  ///A witness that allows us to sweep an HTLC output sent to us in the case that
  ///the remote party broadcasts a revoked commitment state.
  case htlcAcceptedRevoke // = 5

  ///
  ///A witness that allows us to sweep an HTLC output that we extended to a
  ///party, but was never fulfilled.  This HTLC output isn't directly on the
  ///commitment transaction, but is the result of a confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcOfferedTimeoutSecondLevel // = 6

  ///
  ///A witness that allows us to sweep an HTLC output that was offered to us, and
  ///for which we have a payment preimage. This HTLC output isn't directly on our
  ///commitment transaction, but is the result of confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcAcceptedSuccessSecondLevel // = 7

  ///
  ///A witness that allows us to sweep an HTLC that we offered to the remote
  ///party which lies in the commitment transaction of the remote party. We can
  ///spend this output after the absolute CLTV timeout of the HTLC as passed.
  case htlcOfferedRemoteTimeout // = 8

  ///
  ///A witness that allows us to sweep an HTLC that was offered to us by the
  ///remote party. We use this witness in the case that the remote party goes to
  ///chain, and we know the pre-image to the HTLC. We can sweep this without any
  ///additional timeout.
  case htlcAcceptedRemoteSuccess // = 9

  ///
  ///A witness that allows us to sweep an HTLC from the remote party's commitment
  ///transaction in the case that the broadcast a revoked commitment, but then
  ///also immediately attempt to go to the second level to claim the HTLC.
  case htlcSecondLevelRevoke // = 10

  ///
  ///A witness type that allows us to spend a regular p2wkh output that's sent to
  ///an output which is under complete control of the backing wallet.
  case witnessKeyHash // = 11

  ///
  ///A witness type that allows us to sweep an output that sends to a nested P2SH
  ///script that pays to a key solely under our control.
  case nestedWitnessKeyHash // = 12

  ///
  ///A witness type that allows us to spend our anchor on the commitment
  ///transaction.
  case commitmentAnchor // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownWitness
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownWitness
    case 1: self = .commitmentTimeLock
    case 2: self = .commitmentNoDelay
    case 3: self = .commitmentRevoke
    case 4: self = .htlcOfferedRevoke
    case 5: self = .htlcAcceptedRevoke
    case 6: self = .htlcOfferedTimeoutSecondLevel
    case 7: self = .htlcAcceptedSuccessSecondLevel
    case 8: self = .htlcOfferedRemoteTimeout
    case 9: self = .htlcAcceptedRemoteSuccess
    case 10: self = .htlcSecondLevelRevoke
    case 11: self = .witnessKeyHash
    case 12: self = .nestedWitnessKeyHash
    case 13: self = .commitmentAnchor
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownWitness: return 0
    case .commitmentTimeLock: return 1
    case .commitmentNoDelay: return 2
    case .commitmentRevoke: return 3
    case .htlcOfferedRevoke: return 4
    case .htlcAcceptedRevoke: return 5
    case .htlcOfferedTimeoutSecondLevel: return 6
    case .htlcAcceptedSuccessSecondLevel: return 7
    case .htlcOfferedRemoteTimeout: return 8
    case .htlcAcceptedRemoteSuccess: return 9
    case .htlcSecondLevelRevoke: return 10
    case .witnessKeyHash: return 11
    case .nestedWitnessKeyHash: return 12
    case .commitmentAnchor: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Walletrpc_WitnessType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Walletrpc_WitnessType] = [
    .unknownWitness,
    .commitmentTimeLock,
    .commitmentNoDelay,
    .commitmentRevoke,
    .htlcOfferedRevoke,
    .htlcAcceptedRevoke,
    .htlcOfferedTimeoutSecondLevel,
    .htlcAcceptedSuccessSecondLevel,
    .htlcOfferedRemoteTimeout,
    .htlcAcceptedRemoteSuccess,
    .htlcSecondLevelRevoke,
    .witnessKeyHash,
    .nestedWitnessKeyHash,
    .commitmentAnchor,
  ]
}

#endif  // swift(>=4.2)

struct Walletrpc_ListUnspentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum number of confirmations to be included.
  var minConfs: Int32 = 0

  /// The maximum number of confirmations to be included.
  var maxConfs: Int32 = 0

  /// An optional filter to only include outputs belonging to an account.
  var account: String = String()

  ///
  ///When min_confs and max_confs are zero, setting false implicitly
  ///overrides max_confs to be MaxInt32, otherwise max_confs remains
  ///zero. An error is returned if the value is true and both min_confs
  ///and max_confs are non-zero. (default: false)
  var unconfirmedOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListUnspentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of utxos satisfying the specified number of confirmations.
  var utxos: [Lnrpc_Utxo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LeaseOutputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An ID of 32 random bytes that must be unique for each distinct application
  ///using this RPC which will be used to bound the output lease to.
  var id: Data = Data()

  /// The identifying outpoint of the output being leased.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The time in seconds before the lock expires. If set to zero, the default
  /// lock duration is used.
  var expirationSeconds: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_LeaseOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The absolute expiration of the output lease represented as a unix timestamp.
  var expiration: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ReleaseOutputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique ID that was used to lock the output.
  var id: Data = Data()

  /// The identifying outpoint of the output being released.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_ReleaseOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_KeyReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Is the key finger print of the root pubkey that this request is targeting.
  ///This allows the WalletKit to possibly serve out keys for multiple HD chains
  ///via public derivation.
  var keyFingerPrint: Int32 = 0

  ///
  ///The target key family to derive a key from. In other contexts, this is
  ///known as the "account".
  var keyFamily: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddrRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The name of the account to retrieve the next address of. If empty, the
  ///default wallet account is used.
  var account: String = String()

  ///
  ///The type of address to derive.
  var type: Walletrpc_AddressType = .unknown

  ///
  ///Whether a change address should be derived.
  var change: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddrResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The address encoded using a bech32 format.
  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name used to identify the account.
  var name: String = String()

  ///
  ///The type of addresses the account supports.
  ///AddressType                       | External Branch | Internal Branch
  ///---------------------------------------------------------------------
  ///WITNESS_PUBKEY_HASH               | P2WPKH          | P2WPKH
  ///NESTED_WITNESS_PUBKEY_HASH        | NP2WPKH         | NP2WPKH
  ///HYBRID_NESTED_WITNESS_PUBKEY_HASH | NP2WPKH         | P2WPKH
  var addressType: Walletrpc_AddressType = .unknown

  ///
  ///The public key backing the account that all keys are derived from
  ///represented as an extended key. This will always be empty for the default
  ///imported account in which single public keys are imported into.
  var extendedPublicKey: String = String()

  ///
  ///The fingerprint of the root key from which the account public key was
  ///derived from. This will always be zero for the default imported account in
  ///which single public keys are imported into. The bytes are in big-endian
  ///order.
  var masterKeyFingerprint: Data = Data()

  ///
  ///The derivation path corresponding to the account public key. This will
  ///always be empty for the default imported account in which single public keys
  ///are imported into.
  var derivationPath: String = String()

  ///
  ///The number of keys derived from the external branch of the account public
  ///key. This will always be zero for the default imported account in which
  ///single public keys are imported into.
  var externalKeyCount: UInt32 = 0

  ///
  ///The number of keys derived from the internal branch of the account public
  ///key. This will always be zero for the default imported account in which
  ///single public keys are imported into.
  var internalKeyCount: UInt32 = 0

  /// Whether the wallet stores private keys for the account.
  var watchOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An optional filter to only return accounts matching this name.
  var name: String = String()

  /// An optional filter to only return accounts matching this address type.
  var addressType: Walletrpc_AddressType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accounts: [Walletrpc_Account] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ImportAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A name to identify the account with.
  var name: String = String()

  ///
  ///A public key that corresponds to a wallet account represented as an extended
  ///key. It must conform to a derivation path of the form
  ///m/purpose'/coin_type'/account'.
  var extendedPublicKey: String = String()

  ///
  ///The fingerprint of the root key (also known as the key with derivation path
  ///m/) from which the account public key was derived from. This may be required
  ///by some hardware wallets for proper identification and signing. The bytes
  ///must be in big-endian order.
  var masterKeyFingerprint: Data = Data()

  ///
  ///An address type is only required when the extended account public key has a
  ///legacy version (xpub, tpub, etc.), such that the wallet cannot detect what
  ///address scheme it belongs to.
  var addressType: Walletrpc_AddressType = .unknown

  ///
  ///Whether a dry run should be attempted when importing the account. This
  ///serves as a way to confirm whether the account is being imported correctly
  ///by returning the first N addresses for the external and internal branches of
  ///the account. If these addresses match as expected, then it should be safe to
  ///import the account as is.
  var dryRun: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ImportAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The details of the imported account.
  var account: Walletrpc_Account {
    get {return _account ?? Walletrpc_Account()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  ///
  ///The first N addresses that belong to the external branch of the account.
  ///The external branch is typically used for external non-change addresses.
  ///These are only returned if a dry run was specified within the request.
  var dryRunExternalAddrs: [String] = []

  ///
  ///The first N addresses that belong to the internal branch of the account.
  ///The internal branch is typically used for change addresses. These are only
  ///returned if a dry run was specified within the request.
  var dryRunInternalAddrs: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Walletrpc_Account? = nil
}

struct Walletrpc_ImportPublicKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A compressed public key represented as raw bytes.
  var publicKey: Data = Data()

  /// The type of address that will be generated from the public key.
  var addressType: Walletrpc_AddressType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ImportPublicKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The raw serialized transaction.
  var txHex: Data = Data()

  ///
  ///An optional label to save with the transaction. Limited to 500 characters.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If blank, then no error occurred and the transaction was successfully
  ///published. If not the empty string, then a string representation of the
  ///broadcast error.
  ///
  ///TODO(roasbeef): map to a proper enum type
  var publishError: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of satoshis per kilo weight that should be used when crafting
  ///this transaction.
  var satPerKw: Int64 = 0

  ///
  ///A slice of the outputs that should be created in the transaction produced.
  var outputs: [Signrpc_TxOut] = []

  /// An optional label for the transaction, limited to 500 characters.
  var label: String = String()

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The serialized transaction sent out on the network.
  var rawTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of confirmations to shoot for when estimating the fee.
  var confTarget: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The amount of satoshis per kw that should be used in order to reach the
  ///confirmation target in the request.
  var satPerKw: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outpoint of the output we're attempting to sweep.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The witness type of the output we're attempting to sweep.
  var witnessType: Walletrpc_WitnessType = .unknownWitness

  /// The value of the output we're attempting to sweep.
  var amountSat: UInt32 = 0

  ///
  ///Deprecated, use sat_per_vbyte.
  ///The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee
  ///rate is only determined once a sweeping transaction for the output is
  ///created, so it's possible for this to be 0 before this.
  var satPerByte: UInt32 = 0

  /// The number of broadcast attempts we've made to sweep the output.
  var broadcastAttempts: UInt32 = 0

  ///
  ///The next height of the chain at which we'll attempt to broadcast the
  ///sweep transaction of the output.
  var nextBroadcastHeight: UInt32 = 0

  /// The requested confirmation target for this output.
  var requestedConfTarget: UInt32 = 0

  /// Deprecated, use requested_sat_per_vbyte.
  /// The requested fee rate, expressed in sat/vbyte, for this output.
  var requestedSatPerByte: UInt32 = 0

  ///
  ///The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee
  ///rate is only determined once a sweeping transaction for the output is
  ///created, so it's possible for this to be 0 before this.
  var satPerVbyte: UInt64 = 0

  /// The requested fee rate, expressed in sat/vbyte, for this output.
  var requestedSatPerVbyte: UInt64 = 0

  ///
  ///Whether this input must be force-swept. This means that it is swept even
  ///if it has a negative yield.
  var force: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_PendingSweepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The set of outputs currently being swept by lnd's central batching engine.
  var pendingSweeps: [Walletrpc_PendingSweep] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_BumpFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The input we're attempting to bump the fee of.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The target number of blocks that the input should be spent within.
  var targetConf: UInt32 = 0

  ///
  ///Deprecated, use sat_per_vbyte.
  ///The fee rate, expressed in sat/vbyte, that should be used to spend the input
  ///with.
  var satPerByte: UInt32 = 0

  ///
  ///Whether this input must be force-swept. This means that it is swept even
  ///if it has a negative yield.
  var force: Bool = false

  ///
  ///The fee rate, expressed in sat/vbyte, that should be used to spend the input
  ///with.
  var satPerVbyte: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_BumpFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Retrieve the full sweep transaction details. If false, only the sweep txids
  ///will be returned. Note that some sweeps that LND publishes will have been
  ///replaced-by-fee, so will not be included in this output.
  var verbose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sweeps: Walletrpc_ListSweepsResponse.OneOf_Sweeps? = nil

  var transactionDetails: Lnrpc_TransactionDetails {
    get {
      if case .transactionDetails(let v)? = sweeps {return v}
      return Lnrpc_TransactionDetails()
    }
    set {sweeps = .transactionDetails(newValue)}
  }

  var transactionIds: Walletrpc_ListSweepsResponse.TransactionIDs {
    get {
      if case .transactionIds(let v)? = sweeps {return v}
      return Walletrpc_ListSweepsResponse.TransactionIDs()
    }
    set {sweeps = .transactionIds(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Sweeps: Equatable {
    case transactionDetails(Lnrpc_TransactionDetails)
    case transactionIds(Walletrpc_ListSweepsResponse.TransactionIDs)

  #if !swift(>=4.1)
    static func ==(lhs: Walletrpc_ListSweepsResponse.OneOf_Sweeps, rhs: Walletrpc_ListSweepsResponse.OneOf_Sweeps) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transactionDetails, .transactionDetails): return {
        guard case .transactionDetails(let l) = lhs, case .transactionDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transactionIds, .transactionIds): return {
        guard case .transactionIds(let l) = lhs, case .transactionIds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct TransactionIDs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    ///Reversed, hex-encoded string representing the transaction ids of the
    ///sweeps that our node has broadcast. Note that these transactions may
    ///not have confirmed yet, we record sweeps on broadcast, not confirmation.
    var transactionIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Walletrpc_LabelTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The txid of the transaction to label.
  var txid: Data = Data()

  /// The label to add to the transaction, limited to 500 characters.
  var label: String = String()

  /// Whether to overwrite the existing label, if it is present.
  var overwrite: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LabelTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FundPsbtRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var template: Walletrpc_FundPsbtRequest.OneOf_Template? = nil

  ///
  ///Use an existing PSBT packet as the template for the funded PSBT.
  ///
  ///The packet must contain at least one non-dust output. If one or more
  ///inputs are specified, no coin selection is performed. In that case every
  ///input must be an UTXO known to the wallet that has not been locked
  ///before. The sum of all inputs must be sufficiently greater than the sum
  ///of all outputs to pay a miner fee with the specified fee rate. A change
  ///output is added to the PSBT if necessary.
  var psbt: Data {
    get {
      if case .psbt(let v)? = template {return v}
      return Data()
    }
    set {template = .psbt(newValue)}
  }

  ///
  ///Use the outputs and optional inputs from this raw template.
  var raw: Walletrpc_TxTemplate {
    get {
      if case .raw(let v)? = template {return v}
      return Walletrpc_TxTemplate()
    }
    set {template = .raw(newValue)}
  }

  var fees: Walletrpc_FundPsbtRequest.OneOf_Fees? = nil

  ///
  ///The target number of blocks that the transaction should be confirmed in.
  var targetConf: UInt32 {
    get {
      if case .targetConf(let v)? = fees {return v}
      return 0
    }
    set {fees = .targetConf(newValue)}
  }

  ///
  ///The fee rate, expressed in sat/vbyte, that should be used to spend the
  ///input with.
  var satPerVbyte: UInt64 {
    get {
      if case .satPerVbyte(let v)? = fees {return v}
      return 0
    }
    set {fees = .satPerVbyte(newValue)}
  }

  ///
  ///The name of the account to fund the PSBT with. If empty, the default wallet
  ///account is used.
  var account: String = String()

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Template: Equatable {
    ///
    ///Use an existing PSBT packet as the template for the funded PSBT.
    ///
    ///The packet must contain at least one non-dust output. If one or more
    ///inputs are specified, no coin selection is performed. In that case every
    ///input must be an UTXO known to the wallet that has not been locked
    ///before. The sum of all inputs must be sufficiently greater than the sum
    ///of all outputs to pay a miner fee with the specified fee rate. A change
    ///output is added to the PSBT if necessary.
    case psbt(Data)
    ///
    ///Use the outputs and optional inputs from this raw template.
    case raw(Walletrpc_TxTemplate)

  #if !swift(>=4.1)
    static func ==(lhs: Walletrpc_FundPsbtRequest.OneOf_Template, rhs: Walletrpc_FundPsbtRequest.OneOf_Template) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.psbt, .psbt): return {
        guard case .psbt(let l) = lhs, case .psbt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.raw, .raw): return {
        guard case .raw(let l) = lhs, case .raw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_Fees: Equatable {
    ///
    ///The target number of blocks that the transaction should be confirmed in.
    case targetConf(UInt32)
    ///
    ///The fee rate, expressed in sat/vbyte, that should be used to spend the
    ///input with.
    case satPerVbyte(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: Walletrpc_FundPsbtRequest.OneOf_Fees, rhs: Walletrpc_FundPsbtRequest.OneOf_Fees) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetConf, .targetConf): return {
        guard case .targetConf(let l) = lhs, case .targetConf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.satPerVbyte, .satPerVbyte): return {
        guard case .satPerVbyte(let l) = lhs, case .satPerVbyte(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Walletrpc_FundPsbtResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The funded but not yet signed PSBT packet.
  var fundedPsbt: Data = Data()

  ///
  ///The index of the added change output or -1 if no change was left over.
  var changeOutputIndex: Int32 = 0

  ///
  ///The list of lock leases that were acquired for the inputs in the funded PSBT
  ///packet.
  var lockedUtxos: [Walletrpc_UtxoLease] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_TxTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An optional list of inputs to use. Every input must be an UTXO known to the
  ///wallet that has not been locked before. The sum of all inputs must be
  ///sufficiently greater than the sum of all outputs to pay a miner fee with the
  ///fee rate specified in the parent message.
  ///
  ///If no inputs are specified, coin selection will be performed instead and
  ///inputs of sufficient value will be added to the resulting PSBT.
  var inputs: [Lnrpc_OutPoint] = []

  ///
  ///A map of all addresses and the amounts to send to in the funded PSBT.
  var outputs: Dictionary<String,UInt64> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_UtxoLease {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A 32 byte random ID that identifies the lease.
  var id: Data = Data()

  /// The identifying outpoint of the output being leased.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  ///
  ///The absolute expiration of the output lease represented as a unix timestamp.
  var expiration: UInt64 = 0

  ///
  ///The public key script of the leased output.
  var pkScript: Data = Data()

  ///
  ///The value of the leased output in satoshis.
  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_SignPsbtRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The PSBT that should be signed. The PSBT must contain all required inputs,
  ///outputs, UTXO data and custom fields required to identify the signing key.
  var fundedPsbt: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SignPsbtResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signed transaction in PSBT format.
  var signedPsbt: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FinalizePsbtRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A PSBT that should be signed and finalized. The PSBT must contain all
  ///required inputs, outputs, UTXO data and partial signatures of all other
  ///signers.
  var fundedPsbt: Data = Data()

  ///
  ///The name of the account to finalize the PSBT with. If empty, the default
  ///wallet account is used.
  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FinalizePsbtResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully signed and finalized transaction in PSBT format.
  var signedPsbt: Data = Data()

  /// The fully signed and finalized transaction in the raw wire format.
  var rawFinalTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListLeasesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListLeasesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of currently leased utxos.
  var lockedUtxos: [Walletrpc_UtxoLease] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Walletrpc_AddressType: @unchecked Sendable {}
extension Walletrpc_WitnessType: @unchecked Sendable {}
extension Walletrpc_ListUnspentRequest: @unchecked Sendable {}
extension Walletrpc_ListUnspentResponse: @unchecked Sendable {}
extension Walletrpc_LeaseOutputRequest: @unchecked Sendable {}
extension Walletrpc_LeaseOutputResponse: @unchecked Sendable {}
extension Walletrpc_ReleaseOutputRequest: @unchecked Sendable {}
extension Walletrpc_ReleaseOutputResponse: @unchecked Sendable {}
extension Walletrpc_KeyReq: @unchecked Sendable {}
extension Walletrpc_AddrRequest: @unchecked Sendable {}
extension Walletrpc_AddrResponse: @unchecked Sendable {}
extension Walletrpc_Account: @unchecked Sendable {}
extension Walletrpc_ListAccountsRequest: @unchecked Sendable {}
extension Walletrpc_ListAccountsResponse: @unchecked Sendable {}
extension Walletrpc_ImportAccountRequest: @unchecked Sendable {}
extension Walletrpc_ImportAccountResponse: @unchecked Sendable {}
extension Walletrpc_ImportPublicKeyRequest: @unchecked Sendable {}
extension Walletrpc_ImportPublicKeyResponse: @unchecked Sendable {}
extension Walletrpc_Transaction: @unchecked Sendable {}
extension Walletrpc_PublishResponse: @unchecked Sendable {}
extension Walletrpc_SendOutputsRequest: @unchecked Sendable {}
extension Walletrpc_SendOutputsResponse: @unchecked Sendable {}
extension Walletrpc_EstimateFeeRequest: @unchecked Sendable {}
extension Walletrpc_EstimateFeeResponse: @unchecked Sendable {}
extension Walletrpc_PendingSweep: @unchecked Sendable {}
extension Walletrpc_PendingSweepsRequest: @unchecked Sendable {}
extension Walletrpc_PendingSweepsResponse: @unchecked Sendable {}
extension Walletrpc_BumpFeeRequest: @unchecked Sendable {}
extension Walletrpc_BumpFeeResponse: @unchecked Sendable {}
extension Walletrpc_ListSweepsRequest: @unchecked Sendable {}
extension Walletrpc_ListSweepsResponse: @unchecked Sendable {}
extension Walletrpc_ListSweepsResponse.OneOf_Sweeps: @unchecked Sendable {}
extension Walletrpc_ListSweepsResponse.TransactionIDs: @unchecked Sendable {}
extension Walletrpc_LabelTransactionRequest: @unchecked Sendable {}
extension Walletrpc_LabelTransactionResponse: @unchecked Sendable {}
extension Walletrpc_FundPsbtRequest: @unchecked Sendable {}
extension Walletrpc_FundPsbtRequest.OneOf_Template: @unchecked Sendable {}
extension Walletrpc_FundPsbtRequest.OneOf_Fees: @unchecked Sendable {}
extension Walletrpc_FundPsbtResponse: @unchecked Sendable {}
extension Walletrpc_TxTemplate: @unchecked Sendable {}
extension Walletrpc_UtxoLease: @unchecked Sendable {}
extension Walletrpc_SignPsbtRequest: @unchecked Sendable {}
extension Walletrpc_SignPsbtResponse: @unchecked Sendable {}
extension Walletrpc_FinalizePsbtRequest: @unchecked Sendable {}
extension Walletrpc_FinalizePsbtResponse: @unchecked Sendable {}
extension Walletrpc_ListLeasesRequest: @unchecked Sendable {}
extension Walletrpc_ListLeasesResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "walletrpc"

extension Walletrpc_AddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "WITNESS_PUBKEY_HASH"),
    2: .same(proto: "NESTED_WITNESS_PUBKEY_HASH"),
    3: .same(proto: "HYBRID_NESTED_WITNESS_PUBKEY_HASH"),
    4: .same(proto: "TAPROOT_PUBKEY"),
  ]
}

extension Walletrpc_WitnessType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WITNESS"),
    1: .same(proto: "COMMITMENT_TIME_LOCK"),
    2: .same(proto: "COMMITMENT_NO_DELAY"),
    3: .same(proto: "COMMITMENT_REVOKE"),
    4: .same(proto: "HTLC_OFFERED_REVOKE"),
    5: .same(proto: "HTLC_ACCEPTED_REVOKE"),
    6: .same(proto: "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL"),
    7: .same(proto: "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL"),
    8: .same(proto: "HTLC_OFFERED_REMOTE_TIMEOUT"),
    9: .same(proto: "HTLC_ACCEPTED_REMOTE_SUCCESS"),
    10: .same(proto: "HTLC_SECOND_LEVEL_REVOKE"),
    11: .same(proto: "WITNESS_KEY_HASH"),
    12: .same(proto: "NESTED_WITNESS_KEY_HASH"),
    13: .same(proto: "COMMITMENT_ANCHOR"),
  ]
}

extension Walletrpc_ListUnspentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_confs"),
    2: .standard(proto: "max_confs"),
    3: .same(proto: "account"),
    4: .standard(proto: "unconfirmed_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxConfs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.unconfirmedOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 1)
    }
    if self.maxConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxConfs, fieldNumber: 2)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 3)
    }
    if self.unconfirmedOnly != false {
      try visitor.visitSingularBoolField(value: self.unconfirmedOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentRequest, rhs: Walletrpc_ListUnspentRequest) -> Bool {
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.maxConfs != rhs.maxConfs {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unconfirmedOnly != rhs.unconfirmedOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListUnspentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentResponse, rhs: Walletrpc_ListUnspentResponse) -> Bool {
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
    3: .standard(proto: "expiration_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.expirationSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.expirationSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.expirationSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputRequest, rhs: Walletrpc_LeaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.expirationSeconds != rhs.expirationSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.expiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expiration != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputResponse, rhs: Walletrpc_LeaseOutputResponse) -> Bool {
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputRequest, rhs: Walletrpc_ReleaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputResponse, rhs: Walletrpc_ReleaseOutputResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_KeyReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_finger_print"),
    2: .standard(proto: "key_family"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.keyFingerPrint) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.keyFamily) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFingerPrint != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFingerPrint, fieldNumber: 1)
    }
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_KeyReq, rhs: Walletrpc_KeyReq) -> Bool {
    if lhs.keyFingerPrint != rhs.keyFingerPrint {return false}
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "type"),
    3: .same(proto: "change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.change) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.change != false {
      try visitor.visitSingularBoolField(value: self.change, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrRequest, rhs: Walletrpc_AddrRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.type != rhs.type {return false}
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrResponse, rhs: Walletrpc_AddrResponse) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "address_type"),
    3: .standard(proto: "extended_public_key"),
    4: .standard(proto: "master_key_fingerprint"),
    5: .standard(proto: "derivation_path"),
    6: .standard(proto: "external_key_count"),
    7: .standard(proto: "internal_key_count"),
    8: .standard(proto: "watch_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.extendedPublicKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.masterKeyFingerprint) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.derivationPath) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.externalKeyCount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.internalKeyCount) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.watchOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 2)
    }
    if !self.extendedPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.extendedPublicKey, fieldNumber: 3)
    }
    if !self.masterKeyFingerprint.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKeyFingerprint, fieldNumber: 4)
    }
    if !self.derivationPath.isEmpty {
      try visitor.visitSingularStringField(value: self.derivationPath, fieldNumber: 5)
    }
    if self.externalKeyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.externalKeyCount, fieldNumber: 6)
    }
    if self.internalKeyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.internalKeyCount, fieldNumber: 7)
    }
    if self.watchOnly != false {
      try visitor.visitSingularBoolField(value: self.watchOnly, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_Account, rhs: Walletrpc_Account) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.extendedPublicKey != rhs.extendedPublicKey {return false}
    if lhs.masterKeyFingerprint != rhs.masterKeyFingerprint {return false}
    if lhs.derivationPath != rhs.derivationPath {return false}
    if lhs.externalKeyCount != rhs.externalKeyCount {return false}
    if lhs.internalKeyCount != rhs.internalKeyCount {return false}
    if lhs.watchOnly != rhs.watchOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccountsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "address_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListAccountsRequest, rhs: Walletrpc_ListAccountsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccountsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListAccountsResponse, rhs: Walletrpc_ListAccountsResponse) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "extended_public_key"),
    3: .standard(proto: "master_key_fingerprint"),
    4: .standard(proto: "address_type"),
    5: .standard(proto: "dry_run"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.extendedPublicKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.masterKeyFingerprint) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.extendedPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.extendedPublicKey, fieldNumber: 2)
    }
    if !self.masterKeyFingerprint.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKeyFingerprint, fieldNumber: 3)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 4)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportAccountRequest, rhs: Walletrpc_ImportAccountRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.extendedPublicKey != rhs.extendedPublicKey {return false}
    if lhs.masterKeyFingerprint != rhs.masterKeyFingerprint {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "dry_run_external_addrs"),
    3: .standard(proto: "dry_run_internal_addrs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dryRunExternalAddrs) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.dryRunInternalAddrs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.dryRunExternalAddrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dryRunExternalAddrs, fieldNumber: 2)
    }
    if !self.dryRunInternalAddrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dryRunInternalAddrs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportAccountResponse, rhs: Walletrpc_ImportAccountResponse) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.dryRunExternalAddrs != rhs.dryRunExternalAddrs {return false}
    if lhs.dryRunInternalAddrs != rhs.dryRunInternalAddrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportPublicKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportPublicKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "address_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportPublicKeyRequest, rhs: Walletrpc_ImportPublicKeyRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportPublicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportPublicKeyResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportPublicKeyResponse, rhs: Walletrpc_ImportPublicKeyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hex"),
    2: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHex.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHex, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_Transaction, rhs: Walletrpc_Transaction) -> Bool {
    if lhs.txHex != rhs.txHex {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publish_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publishError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishError.isEmpty {
      try visitor.visitSingularStringField(value: self.publishError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PublishResponse, rhs: Walletrpc_PublishResponse) -> Bool {
    if lhs.publishError != rhs.publishError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
    2: .same(proto: "outputs"),
    3: .same(proto: "label"),
    4: .standard(proto: "min_confs"),
    5: .standard(proto: "spend_unconfirmed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.satPerKw) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 4)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsRequest, rhs: Walletrpc_SendOutputsRequest) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.label != rhs.label {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsResponse, rhs: Walletrpc_SendOutputsResponse) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conf_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confTarget != 0 {
      try visitor.visitSingularInt32Field(value: self.confTarget, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeRequest, rhs: Walletrpc_EstimateFeeRequest) -> Bool {
    if lhs.confTarget != rhs.confTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.satPerKw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeResponse, rhs: Walletrpc_EstimateFeeResponse) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "witness_type"),
    3: .standard(proto: "amount_sat"),
    4: .standard(proto: "sat_per_byte"),
    5: .standard(proto: "broadcast_attempts"),
    6: .standard(proto: "next_broadcast_height"),
    8: .standard(proto: "requested_conf_target"),
    9: .standard(proto: "requested_sat_per_byte"),
    10: .standard(proto: "sat_per_vbyte"),
    11: .standard(proto: "requested_sat_per_vbyte"),
    7: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.witnessType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.amountSat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.satPerByte) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.broadcastAttempts) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.nextBroadcastHeight) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.requestedConfTarget) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.requestedSatPerByte) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.requestedSatPerVbyte) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.witnessType != .unknownWitness {
      try visitor.visitSingularEnumField(value: self.witnessType, fieldNumber: 2)
    }
    if self.amountSat != 0 {
      try visitor.visitSingularUInt32Field(value: self.amountSat, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 4)
    }
    if self.broadcastAttempts != 0 {
      try visitor.visitSingularUInt32Field(value: self.broadcastAttempts, fieldNumber: 5)
    }
    if self.nextBroadcastHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextBroadcastHeight, fieldNumber: 6)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 7)
    }
    if self.requestedConfTarget != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedConfTarget, fieldNumber: 8)
    }
    if self.requestedSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedSatPerByte, fieldNumber: 9)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 10)
    }
    if self.requestedSatPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestedSatPerVbyte, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweep, rhs: Walletrpc_PendingSweep) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.witnessType != rhs.witnessType {return false}
    if lhs.amountSat != rhs.amountSat {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.broadcastAttempts != rhs.broadcastAttempts {return false}
    if lhs.nextBroadcastHeight != rhs.nextBroadcastHeight {return false}
    if lhs.requestedConfTarget != rhs.requestedConfTarget {return false}
    if lhs.requestedSatPerByte != rhs.requestedSatPerByte {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.requestedSatPerVbyte != rhs.requestedSatPerVbyte {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsRequest, rhs: Walletrpc_PendingSweepsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_sweeps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pendingSweeps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingSweeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingSweeps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsResponse, rhs: Walletrpc_PendingSweepsResponse) -> Bool {
    if lhs.pendingSweeps != rhs.pendingSweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "target_conf"),
    3: .standard(proto: "sat_per_byte"),
    4: .same(proto: "force"),
    5: .standard(proto: "sat_per_vbyte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.targetConf) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.satPerByte) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.targetConf != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetConf, fieldNumber: 2)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 3)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 4)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeRequest, rhs: Walletrpc_BumpFeeRequest) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.force != rhs.force {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeResponse, rhs: Walletrpc_BumpFeeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verbose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsRequest, rhs: Walletrpc_ListSweepsRequest) -> Bool {
    if lhs.verbose != rhs.verbose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_details"),
    2: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_TransactionDetails?
        var hadOneofValue = false
        if let current = self.sweeps {
          hadOneofValue = true
          if case .transactionDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sweeps = .transactionDetails(v)
        }
      }()
      case 2: try {
        var v: Walletrpc_ListSweepsResponse.TransactionIDs?
        var hadOneofValue = false
        if let current = self.sweeps {
          hadOneofValue = true
          if case .transactionIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sweeps = .transactionIds(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sweeps {
    case .transactionDetails?: try {
      guard case .transactionDetails(let v)? = self.sweeps else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .transactionIds?: try {
      guard case .transactionIds(let v)? = self.sweeps else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse, rhs: Walletrpc_ListSweepsResponse) -> Bool {
    if lhs.sweeps != rhs.sweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse.TransactionIDs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Walletrpc_ListSweepsResponse.protoMessageName + ".TransactionIDs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.transactionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse.TransactionIDs, rhs: Walletrpc_ListSweepsResponse.TransactionIDs) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "label"),
    3: .same(proto: "overwrite"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.overwrite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.overwrite != false {
      try visitor.visitSingularBoolField(value: self.overwrite, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionRequest, rhs: Walletrpc_LabelTransactionRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.label != rhs.label {return false}
    if lhs.overwrite != rhs.overwrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionResponse, rhs: Walletrpc_LabelTransactionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FundPsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundPsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .same(proto: "raw"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_vbyte"),
    5: .same(proto: "account"),
    6: .standard(proto: "min_confs"),
    7: .standard(proto: "spend_unconfirmed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.template != nil {try decoder.handleConflictingOneOf()}
          self.template = .psbt(v)
        }
      }()
      case 2: try {
        var v: Walletrpc_TxTemplate?
        var hadOneofValue = false
        if let current = self.template {
          hadOneofValue = true
          if case .raw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.template = .raw(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.fees != nil {try decoder.handleConflictingOneOf()}
          self.fees = .targetConf(v)
        }
      }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.fees != nil {try decoder.handleConflictingOneOf()}
          self.fees = .satPerVbyte(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.template {
    case .psbt?: try {
      guard case .psbt(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .raw?: try {
      guard case .raw(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.fees {
    case .targetConf?: try {
      guard case .targetConf(let v)? = self.fees else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .satPerVbyte?: try {
      guard case .satPerVbyte(let v)? = self.fees else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 5)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 6)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FundPsbtRequest, rhs: Walletrpc_FundPsbtRequest) -> Bool {
    if lhs.template != rhs.template {return false}
    if lhs.fees != rhs.fees {return false}
    if lhs.account != rhs.account {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FundPsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundPsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
    2: .standard(proto: "change_output_index"),
    3: .standard(proto: "locked_utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.changeOutputIndex) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.lockedUtxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    if self.changeOutputIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.changeOutputIndex, fieldNumber: 2)
    }
    if !self.lockedUtxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lockedUtxos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FundPsbtResponse, rhs: Walletrpc_FundPsbtResponse) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.changeOutputIndex != rhs.changeOutputIndex {return false}
    if lhs.lockedUtxos != rhs.lockedUtxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_TxTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxTemplate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.outputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_TxTemplate, rhs: Walletrpc_TxTemplate) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_UtxoLease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxoLease"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
    3: .same(proto: "expiration"),
    4: .standard(proto: "pk_script"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.expiration) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.pkScript) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.expiration != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiration, fieldNumber: 3)
    }
    if !self.pkScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.pkScript, fieldNumber: 4)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_UtxoLease, rhs: Walletrpc_UtxoLease) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.pkScript != rhs.pkScript {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SignPsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignPsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SignPsbtRequest, rhs: Walletrpc_SignPsbtRequest) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SignPsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignPsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_psbt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedPsbt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPsbt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SignPsbtResponse, rhs: Walletrpc_SignPsbtResponse) -> Bool {
    if lhs.signedPsbt != rhs.signedPsbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FinalizePsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizePsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
    5: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FinalizePsbtRequest, rhs: Walletrpc_FinalizePsbtRequest) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FinalizePsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizePsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_psbt"),
    2: .standard(proto: "raw_final_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedPsbt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawFinalTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPsbt, fieldNumber: 1)
    }
    if !self.rawFinalTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawFinalTx, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FinalizePsbtResponse, rhs: Walletrpc_FinalizePsbtResponse) -> Bool {
    if lhs.signedPsbt != rhs.signedPsbt {return false}
    if lhs.rawFinalTx != rhs.rawFinalTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListLeasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLeasesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListLeasesRequest, rhs: Walletrpc_ListLeasesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListLeasesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLeasesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "locked_utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lockedUtxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lockedUtxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lockedUtxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListLeasesResponse, rhs: Walletrpc_ListLeasesResponse) -> Bool {
    if lhs.lockedUtxos != rhs.lockedUtxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
