// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: signrpc/signer.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Signrpc_SignMethod: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  ///Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be
  ///signed.
  case witnessV0 // = 0

  ///
  ///Specifies that a SegWit v1 (p2tr) input should be signed by using the
  ///BIP0086 method (commit to internal key only).
  case taprootKeySpendBip0086 // = 1

  ///
  ///Specifies that a SegWit v1 (p2tr) input should be signed by using a given
  ///taproot hash to commit to in addition to the internal key.
  case taprootKeySpend // = 2

  ///
  ///Specifies that a SegWit v1 (p2tr) input should be spent using the script
  ///path and that a specific leaf script should be signed for.
  case taprootScriptSpend // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .witnessV0
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .witnessV0
    case 1: self = .taprootKeySpendBip0086
    case 2: self = .taprootKeySpend
    case 3: self = .taprootScriptSpend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .witnessV0: return 0
    case .taprootKeySpendBip0086: return 1
    case .taprootKeySpend: return 2
    case .taprootScriptSpend: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Signrpc_SignMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Signrpc_SignMethod] = [
    .witnessV0,
    .taprootKeySpendBip0086,
    .taprootKeySpend,
    .taprootScriptSpend,
  ]
}

#endif  // swift(>=4.2)

struct Signrpc_KeyLocator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The family of key being identified.
  var keyFamily: Int32 = 0

  /// The precise index of the key being identified.
  var keyIndex: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_KeyDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The raw bytes of the public key in the key pair being identified. Either
  ///this or the KeyLocator must be specified.
  var rawKeyBytes: Data = Data()

  ///
  ///The key locator that identifies which private key to use for signing.
  ///Either this or the raw bytes of the target public key must be specified.
  var keyLoc: Signrpc_KeyLocator {
    get {return _keyLoc ?? Signrpc_KeyLocator()}
    set {_keyLoc = newValue}
  }
  /// Returns true if `keyLoc` has been explicitly set.
  var hasKeyLoc: Bool {return self._keyLoc != nil}
  /// Clears the value of `keyLoc`. Subsequent reads from it will return its default value.
  mutating func clearKeyLoc() {self._keyLoc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyLoc: Signrpc_KeyLocator? = nil
}

struct Signrpc_TxOut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value of the output being spent.
  var value: Int64 = 0

  /// The script of the output being spent.
  var pkScript: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_SignDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A descriptor that precisely describes *which* key to use for signing. This
  ///may provide the raw public key directly, or require the Signer to re-derive
  ///the key according to the populated derivation path.
  ///
  ///Note that if the key descriptor was obtained through walletrpc.DeriveKey,
  ///then the key locator MUST always be provided, since the derived keys are not
  ///persisted unlike with DeriveNextKey.
  var keyDesc: Signrpc_KeyDescriptor {
    get {return _keyDesc ?? Signrpc_KeyDescriptor()}
    set {_keyDesc = newValue}
  }
  /// Returns true if `keyDesc` has been explicitly set.
  var hasKeyDesc: Bool {return self._keyDesc != nil}
  /// Clears the value of `keyDesc`. Subsequent reads from it will return its default value.
  mutating func clearKeyDesc() {self._keyDesc = nil}

  ///
  ///A scalar value that will be added to the private key corresponding to the
  ///above public key to obtain the private key to be used to sign this input.
  ///This value is typically derived via the following computation:
  ///
  /// derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
  var singleTweak: Data = Data()

  ///
  ///A private key that will be used in combination with its corresponding
  ///private key to derive the private key that is to be used to sign the target
  ///input. Within the Lightning protocol, this value is typically the
  ///commitment secret from a previously revoked commitment transaction. This
  ///value is in combination with two hash values, and the original private key
  ///to derive the private key to be used when signing.
  ///
  /// k = (privKey*sha256(pubKey || tweakPub) +
  ///tweakPriv*sha256(tweakPub || pubKey)) mod N
  var doubleTweak: Data = Data()

  ///
  ///The 32 byte input to the taproot tweak derivation that is used to derive
  ///the output key from an internal key: outputKey = internalKey +
  ///tagged_hash("tapTweak", internalKey || tapTweak).
  ///
  ///When doing a BIP 86 spend, this field can be an empty byte slice.
  ///
  ///When doing a normal key path spend, with the output key committing to an
  ///actual script root, then this field should be: the tapscript root hash.
  var tapTweak: Data = Data()

  ///
  ///The full script required to properly redeem the output. This field will
  ///only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
  ///taproot script path spend is being attempted, then this should be the raw
  ///leaf script.
  var witnessScript: Data = Data()

  ///
  ///A description of the output being spent. The value and script MUST be
  ///provided.
  var output: Signrpc_TxOut {
    get {return _output ?? Signrpc_TxOut()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  mutating func clearOutput() {self._output = nil}

  ///
  ///The target sighash type that should be used when generating the final
  ///sighash, and signature.
  var sighash: UInt32 = 0

  ///
  ///The target input within the transaction that should be signed.
  var inputIndex: Int32 = 0

  ///
  ///The sign method specifies how the input should be signed. Depending on the
  ///method, either the tap_tweak, witness_script or both need to be specified.
  ///Defaults to SegWit v0 signing to be backward compatible with older RPC
  ///clients.
  var signMethod: Signrpc_SignMethod = .witnessV0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyDesc: Signrpc_KeyDescriptor? = nil
  fileprivate var _output: Signrpc_TxOut? = nil
}

struct Signrpc_SignReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The raw bytes of the transaction to be signed.
  var rawTxBytes: Data = Data()

  /// A set of sign descriptors, for each input to be signed.
  var signDescs: [Signrpc_SignDescriptor] = []

  ///
  ///The full list of UTXO information for each of the inputs being spent. This
  ///is required when spending one or more taproot (SegWit v1) outputs.
  var prevOutputs: [Signrpc_TxOut] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_SignResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A set of signatures realized in a fixed 64-byte format ordered in ascending
  ///input order.
  var rawSigs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_InputScript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The serializes witness stack for the specified input.
  var witness: [Data] = []

  ///
  ///The optional sig script for the specified witness that will only be set if
  ///the input specified is a nested p2sh witness program.
  var sigScript: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_InputScriptResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of fully valid input scripts requested.
  var inputScripts: [Signrpc_InputScript] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_SignMessageReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message to be signed.
  var msg: Data = Data()

  /// The key locator that identifies which key to use for signing.
  var keyLoc: Signrpc_KeyLocator {
    get {return _keyLoc ?? Signrpc_KeyLocator()}
    set {_keyLoc = newValue}
  }
  /// Returns true if `keyLoc` has been explicitly set.
  var hasKeyLoc: Bool {return self._keyLoc != nil}
  /// Clears the value of `keyLoc`. Subsequent reads from it will return its default value.
  mutating func clearKeyLoc() {self._keyLoc = nil}

  /// Double-SHA256 hash instead of just the default single round.
  var doubleHash: Bool = false

  ///
  ///Use the compact (pubkey recoverable) format instead of the raw lnwire
  ///format.
  var compactSig: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyLoc: Signrpc_KeyLocator? = nil
}

struct Signrpc_SignMessageResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The signature for the given message in the fixed-size LN wire format.
  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_VerifyMessageReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message over which the signature is to be verified.
  var msg: Data = Data()

  ///
  ///The fixed-size LN wire encoded signature to be verified over the given
  ///message.
  var signature: Data = Data()

  /// The public key the signature has to be valid for.
  var pubkey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_VerifyMessageResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the signature was valid over the given message.
  var valid: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_SharedKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ephemeral public key to use for the DH key derivation.
  var ephemeralPubkey: Data = Data()

  ///
  ///Deprecated. The optional key locator of the local key that should be used.
  ///If this parameter is not set then the node's identity private key will be
  ///used.
  var keyLoc: Signrpc_KeyLocator {
    get {return _keyLoc ?? Signrpc_KeyLocator()}
    set {_keyLoc = newValue}
  }
  /// Returns true if `keyLoc` has been explicitly set.
  var hasKeyLoc: Bool {return self._keyLoc != nil}
  /// Clears the value of `keyLoc`. Subsequent reads from it will return its default value.
  mutating func clearKeyLoc() {self._keyLoc = nil}

  ///
  ///A key descriptor describes the key used for performing ECDH. Either a key
  ///locator or a raw public key is expected, if neither is supplied, defaults to
  ///the node's identity private key.
  var keyDesc: Signrpc_KeyDescriptor {
    get {return _keyDesc ?? Signrpc_KeyDescriptor()}
    set {_keyDesc = newValue}
  }
  /// Returns true if `keyDesc` has been explicitly set.
  var hasKeyDesc: Bool {return self._keyDesc != nil}
  /// Clears the value of `keyDesc`. Subsequent reads from it will return its default value.
  mutating func clearKeyDesc() {self._keyDesc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyLoc: Signrpc_KeyLocator? = nil
  fileprivate var _keyDesc: Signrpc_KeyDescriptor? = nil
}

struct Signrpc_SharedKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The shared public key, hashed with sha256.
  var sharedKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_TweakDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Tweak is the 32-byte value that will modify the public key.
  var tweak: Data = Data()

  ///
  ///Specifies if the target key should be converted to an x-only public key
  ///before tweaking. If true, then the public key will be mapped to an x-only
  ///key before the tweaking operation is applied.
  var isXOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_TaprootTweakDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The root hash of the tapscript tree if a script path is committed to. If
  ///the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
  ///key spend only), then this needs to be empty and the key_spend_only field
  ///below must be set to true. This is required because gRPC cannot
  ///differentiate between a zero-size byte slice and a nil byte slice (both
  ///would be serialized the same way). So the extra boolean is required.
  var scriptRoot: Data = Data()

  ///
  ///Indicates that the above script_root is expected to be empty because this
  ///is a BIP-0086 key spend only commitment where only the internal key is
  ///committed to instead of also including a script root hash.
  var keySpendOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2CombineKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A list of all public keys (serialized in 32-byte x-only format!)
  ///participating in the signing session. The list will always be sorted
  ///lexicographically internally. This must include the local key which is
  ///described by the above key_loc.
  var allSignerPubkeys: [Data] = []

  ///
  ///A series of optional generic tweaks to be applied to the the aggregated
  ///public key.
  var tweaks: [Signrpc_TweakDesc] = []

  ///
  ///An optional taproot specific tweak that must be specified if the MuSig2
  ///combined key will be used as the main taproot key of a taproot output
  ///on-chain.
  var taprootTweak: Signrpc_TaprootTweakDesc {
    get {return _taprootTweak ?? Signrpc_TaprootTweakDesc()}
    set {_taprootTweak = newValue}
  }
  /// Returns true if `taprootTweak` has been explicitly set.
  var hasTaprootTweak: Bool {return self._taprootTweak != nil}
  /// Clears the value of `taprootTweak`. Subsequent reads from it will return its default value.
  mutating func clearTaprootTweak() {self._taprootTweak = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _taprootTweak: Signrpc_TaprootTweakDesc? = nil
}

struct Signrpc_MuSig2CombineKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The combined public key (in the 32-byte x-only format) with all tweaks
  ///applied to it. If a taproot tweak is specified, this corresponds to the
  ///taproot key that can be put into the on-chain output.
  var combinedKey: Data = Data()

  ///
  ///The raw combined public key (in the 32-byte x-only format) before any tweaks
  ///are applied to it. If a taproot tweak is specified, this corresponds to the
  ///internal key that needs to be put into the witness if the script spend path
  ///is used.
  var taprootInternalKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2SessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The key locator that identifies which key to use for signing.
  var keyLoc: Signrpc_KeyLocator {
    get {return _keyLoc ?? Signrpc_KeyLocator()}
    set {_keyLoc = newValue}
  }
  /// Returns true if `keyLoc` has been explicitly set.
  var hasKeyLoc: Bool {return self._keyLoc != nil}
  /// Clears the value of `keyLoc`. Subsequent reads from it will return its default value.
  mutating func clearKeyLoc() {self._keyLoc = nil}

  ///
  ///A list of all public keys (serialized in 32-byte x-only format!)
  ///participating in the signing session. The list will always be sorted
  ///lexicographically internally. This must include the local key which is
  ///described by the above key_loc.
  var allSignerPubkeys: [Data] = []

  ///
  ///An optional list of all public nonces of other signing participants that
  ///might already be known.
  var otherSignerPublicNonces: [Data] = []

  ///
  ///A series of optional generic tweaks to be applied to the the aggregated
  ///public key.
  var tweaks: [Signrpc_TweakDesc] = []

  ///
  ///An optional taproot specific tweak that must be specified if the MuSig2
  ///combined key will be used as the main taproot key of a taproot output
  ///on-chain.
  var taprootTweak: Signrpc_TaprootTweakDesc {
    get {return _taprootTweak ?? Signrpc_TaprootTweakDesc()}
    set {_taprootTweak = newValue}
  }
  /// Returns true if `taprootTweak` has been explicitly set.
  var hasTaprootTweak: Bool {return self._taprootTweak != nil}
  /// Clears the value of `taprootTweak`. Subsequent reads from it will return its default value.
  mutating func clearTaprootTweak() {self._taprootTweak = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyLoc: Signrpc_KeyLocator? = nil
  fileprivate var _taprootTweak: Signrpc_TaprootTweakDesc? = nil
}

struct Signrpc_MuSig2SessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique ID that represents this signing session. A session can be used
  ///for producing a signature a single time. If the signing fails for any
  ///reason, a new session with the same participants needs to be created.
  var sessionID: Data = Data()

  ///
  ///The combined public key (in the 32-byte x-only format) with all tweaks
  ///applied to it. If a taproot tweak is specified, this corresponds to the
  ///taproot key that can be put into the on-chain output.
  var combinedKey: Data = Data()

  ///
  ///The raw combined public key (in the 32-byte x-only format) before any tweaks
  ///are applied to it. If a taproot tweak is specified, this corresponds to the
  ///internal key that needs to be put into the witness if the script spend path
  ///is used.
  var taprootInternalKey: Data = Data()

  ///
  ///The two public nonces the local signer uses, combined into a single value
  ///of 66 bytes. Can be split into the two 33-byte points to get the individual
  ///nonces.
  var localPublicNonces: Data = Data()

  ///
  ///Indicates whether all nonces required to start the signing process are known
  ///now.
  var haveAllNonces: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2RegisterNoncesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique ID of the signing session those nonces should be registered with.
  var sessionID: Data = Data()

  ///
  ///A list of all public nonces of other signing participants that should be
  ///registered.
  var otherSignerPublicNonces: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2RegisterNoncesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Indicates whether all nonces required to start the signing process are known
  ///now.
  var haveAllNonces: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2SignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique ID of the signing session to use for signing.
  var sessionID: Data = Data()

  ///
  ///The 32-byte SHA256 digest of the message to sign.
  var messageDigest: Data = Data()

  ///
  ///Cleanup indicates that after signing, the session state can be cleaned up,
  ///since another participant is going to be responsible for combining the
  ///partial signatures.
  var cleanup: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2SignResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The partial signature created by the local signer.
  var localPartialSignature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2CombineSigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique ID of the signing session to combine the signatures for.
  var sessionID: Data = Data()

  ///
  ///The list of all other participants' partial signatures to add to the current
  ///session.
  var otherPartialSignatures: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2CombineSigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Indicates whether all partial signatures required to create a final, full
  ///signature are known yet. If this is true, then the final_signature field is
  ///set, otherwise it is empty.
  var haveAllSignatures: Bool = false

  ///
  ///The final, full signature that is valid for the combined public key.
  var finalSignature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2CleanupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique ID of the signing session that should be removed/cleaned up.
  var sessionID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_MuSig2CleanupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Signrpc_SignMethod: @unchecked Sendable {}
extension Signrpc_KeyLocator: @unchecked Sendable {}
extension Signrpc_KeyDescriptor: @unchecked Sendable {}
extension Signrpc_TxOut: @unchecked Sendable {}
extension Signrpc_SignDescriptor: @unchecked Sendable {}
extension Signrpc_SignReq: @unchecked Sendable {}
extension Signrpc_SignResp: @unchecked Sendable {}
extension Signrpc_InputScript: @unchecked Sendable {}
extension Signrpc_InputScriptResp: @unchecked Sendable {}
extension Signrpc_SignMessageReq: @unchecked Sendable {}
extension Signrpc_SignMessageResp: @unchecked Sendable {}
extension Signrpc_VerifyMessageReq: @unchecked Sendable {}
extension Signrpc_VerifyMessageResp: @unchecked Sendable {}
extension Signrpc_SharedKeyRequest: @unchecked Sendable {}
extension Signrpc_SharedKeyResponse: @unchecked Sendable {}
extension Signrpc_TweakDesc: @unchecked Sendable {}
extension Signrpc_TaprootTweakDesc: @unchecked Sendable {}
extension Signrpc_MuSig2CombineKeysRequest: @unchecked Sendable {}
extension Signrpc_MuSig2CombineKeysResponse: @unchecked Sendable {}
extension Signrpc_MuSig2SessionRequest: @unchecked Sendable {}
extension Signrpc_MuSig2SessionResponse: @unchecked Sendable {}
extension Signrpc_MuSig2RegisterNoncesRequest: @unchecked Sendable {}
extension Signrpc_MuSig2RegisterNoncesResponse: @unchecked Sendable {}
extension Signrpc_MuSig2SignRequest: @unchecked Sendable {}
extension Signrpc_MuSig2SignResponse: @unchecked Sendable {}
extension Signrpc_MuSig2CombineSigRequest: @unchecked Sendable {}
extension Signrpc_MuSig2CombineSigResponse: @unchecked Sendable {}
extension Signrpc_MuSig2CleanupRequest: @unchecked Sendable {}
extension Signrpc_MuSig2CleanupResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "signrpc"

extension Signrpc_SignMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGN_METHOD_WITNESS_V0"),
    1: .same(proto: "SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086"),
    2: .same(proto: "SIGN_METHOD_TAPROOT_KEY_SPEND"),
    3: .same(proto: "SIGN_METHOD_TAPROOT_SCRIPT_SPEND"),
  ]
}

extension Signrpc_KeyLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_family"),
    2: .standard(proto: "key_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.keyFamily) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.keyIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 1)
    }
    if self.keyIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.keyIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_KeyLocator, rhs: Signrpc_KeyLocator) -> Bool {
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.keyIndex != rhs.keyIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_KeyDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_key_bytes"),
    2: .standard(proto: "key_loc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawKeyBytes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keyLoc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rawKeyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawKeyBytes, fieldNumber: 1)
    }
    try { if let v = self._keyLoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_KeyDescriptor, rhs: Signrpc_KeyDescriptor) -> Bool {
    if lhs.rawKeyBytes != rhs.rawKeyBytes {return false}
    if lhs._keyLoc != rhs._keyLoc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_TxOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxOut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "pk_script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pkScript) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if !self.pkScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.pkScript, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_TxOut, rhs: Signrpc_TxOut) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.pkScript != rhs.pkScript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_desc"),
    2: .standard(proto: "single_tweak"),
    3: .standard(proto: "double_tweak"),
    10: .standard(proto: "tap_tweak"),
    4: .standard(proto: "witness_script"),
    5: .same(proto: "output"),
    7: .same(proto: "sighash"),
    8: .standard(proto: "input_index"),
    9: .standard(proto: "sign_method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyDesc) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.singleTweak) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.doubleTweak) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.witnessScript) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.sighash) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.inputIndex) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.signMethod) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.tapTweak) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyDesc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.singleTweak.isEmpty {
      try visitor.visitSingularBytesField(value: self.singleTweak, fieldNumber: 2)
    }
    if !self.doubleTweak.isEmpty {
      try visitor.visitSingularBytesField(value: self.doubleTweak, fieldNumber: 3)
    }
    if !self.witnessScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessScript, fieldNumber: 4)
    }
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.sighash != 0 {
      try visitor.visitSingularUInt32Field(value: self.sighash, fieldNumber: 7)
    }
    if self.inputIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.inputIndex, fieldNumber: 8)
    }
    if self.signMethod != .witnessV0 {
      try visitor.visitSingularEnumField(value: self.signMethod, fieldNumber: 9)
    }
    if !self.tapTweak.isEmpty {
      try visitor.visitSingularBytesField(value: self.tapTweak, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignDescriptor, rhs: Signrpc_SignDescriptor) -> Bool {
    if lhs._keyDesc != rhs._keyDesc {return false}
    if lhs.singleTweak != rhs.singleTweak {return false}
    if lhs.doubleTweak != rhs.doubleTweak {return false}
    if lhs.tapTweak != rhs.tapTweak {return false}
    if lhs.witnessScript != rhs.witnessScript {return false}
    if lhs._output != rhs._output {return false}
    if lhs.sighash != rhs.sighash {return false}
    if lhs.inputIndex != rhs.inputIndex {return false}
    if lhs.signMethod != rhs.signMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx_bytes"),
    2: .standard(proto: "sign_descs"),
    3: .standard(proto: "prev_outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTxBytes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.signDescs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.prevOutputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTxBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTxBytes, fieldNumber: 1)
    }
    if !self.signDescs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signDescs, fieldNumber: 2)
    }
    if !self.prevOutputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prevOutputs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignReq, rhs: Signrpc_SignReq) -> Bool {
    if lhs.rawTxBytes != rhs.rawTxBytes {return false}
    if lhs.signDescs != rhs.signDescs {return false}
    if lhs.prevOutputs != rhs.prevOutputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_sigs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.rawSigs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawSigs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.rawSigs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignResp, rhs: Signrpc_SignResp) -> Bool {
    if lhs.rawSigs != rhs.rawSigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_InputScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InputScript"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "witness"),
    2: .standard(proto: "sig_script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.witness) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sigScript) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.witness.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.witness, fieldNumber: 1)
    }
    if !self.sigScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.sigScript, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_InputScript, rhs: Signrpc_InputScript) -> Bool {
    if lhs.witness != rhs.witness {return false}
    if lhs.sigScript != rhs.sigScript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_InputScriptResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InputScriptResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_scripts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputScripts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputScripts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputScripts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_InputScriptResp, rhs: Signrpc_InputScriptResp) -> Bool {
    if lhs.inputScripts != rhs.inputScripts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .standard(proto: "key_loc"),
    3: .standard(proto: "double_hash"),
    4: .standard(proto: "compact_sig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keyLoc) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.doubleHash) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.compactSig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    try { if let v = self._keyLoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.doubleHash != false {
      try visitor.visitSingularBoolField(value: self.doubleHash, fieldNumber: 3)
    }
    if self.compactSig != false {
      try visitor.visitSingularBoolField(value: self.compactSig, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignMessageReq, rhs: Signrpc_SignMessageReq) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs._keyLoc != rhs._keyLoc {return false}
    if lhs.doubleHash != rhs.doubleHash {return false}
    if lhs.compactSig != rhs.compactSig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignMessageResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignMessageResp, rhs: Signrpc_SignMessageResp) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_VerifyMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "signature"),
    3: .same(proto: "pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_VerifyMessageReq, rhs: Signrpc_VerifyMessageReq) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_VerifyMessageResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_VerifyMessageResp, rhs: Signrpc_VerifyMessageResp) -> Bool {
    if lhs.valid != rhs.valid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SharedKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SharedKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ephemeral_pubkey"),
    2: .standard(proto: "key_loc"),
    3: .standard(proto: "key_desc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ephemeralPubkey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keyLoc) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._keyDesc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ephemeralPubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.ephemeralPubkey, fieldNumber: 1)
    }
    try { if let v = self._keyLoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._keyDesc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SharedKeyRequest, rhs: Signrpc_SharedKeyRequest) -> Bool {
    if lhs.ephemeralPubkey != rhs.ephemeralPubkey {return false}
    if lhs._keyLoc != rhs._keyLoc {return false}
    if lhs._keyDesc != rhs._keyDesc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SharedKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SharedKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shared_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sharedKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sharedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.sharedKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SharedKeyResponse, rhs: Signrpc_SharedKeyResponse) -> Bool {
    if lhs.sharedKey != rhs.sharedKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_TweakDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TweakDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tweak"),
    2: .standard(proto: "is_x_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tweak) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isXOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tweak.isEmpty {
      try visitor.visitSingularBytesField(value: self.tweak, fieldNumber: 1)
    }
    if self.isXOnly != false {
      try visitor.visitSingularBoolField(value: self.isXOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_TweakDesc, rhs: Signrpc_TweakDesc) -> Bool {
    if lhs.tweak != rhs.tweak {return false}
    if lhs.isXOnly != rhs.isXOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_TaprootTweakDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TaprootTweakDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "script_root"),
    2: .standard(proto: "key_spend_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scriptRoot) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keySpendOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scriptRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.scriptRoot, fieldNumber: 1)
    }
    if self.keySpendOnly != false {
      try visitor.visitSingularBoolField(value: self.keySpendOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_TaprootTweakDesc, rhs: Signrpc_TaprootTweakDesc) -> Bool {
    if lhs.scriptRoot != rhs.scriptRoot {return false}
    if lhs.keySpendOnly != rhs.keySpendOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2CombineKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2CombineKeysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "all_signer_pubkeys"),
    2: .same(proto: "tweaks"),
    3: .standard(proto: "taproot_tweak"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.allSignerPubkeys) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tweaks) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._taprootTweak) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.allSignerPubkeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.allSignerPubkeys, fieldNumber: 1)
    }
    if !self.tweaks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tweaks, fieldNumber: 2)
    }
    try { if let v = self._taprootTweak {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2CombineKeysRequest, rhs: Signrpc_MuSig2CombineKeysRequest) -> Bool {
    if lhs.allSignerPubkeys != rhs.allSignerPubkeys {return false}
    if lhs.tweaks != rhs.tweaks {return false}
    if lhs._taprootTweak != rhs._taprootTweak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2CombineKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2CombineKeysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "combined_key"),
    2: .standard(proto: "taproot_internal_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.combinedKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.taprootInternalKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.combinedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.combinedKey, fieldNumber: 1)
    }
    if !self.taprootInternalKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.taprootInternalKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2CombineKeysResponse, rhs: Signrpc_MuSig2CombineKeysResponse) -> Bool {
    if lhs.combinedKey != rhs.combinedKey {return false}
    if lhs.taprootInternalKey != rhs.taprootInternalKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2SessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2SessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_loc"),
    2: .standard(proto: "all_signer_pubkeys"),
    3: .standard(proto: "other_signer_public_nonces"),
    4: .same(proto: "tweaks"),
    5: .standard(proto: "taproot_tweak"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyLoc) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.allSignerPubkeys) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.otherSignerPublicNonces) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tweaks) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._taprootTweak) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyLoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.allSignerPubkeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.allSignerPubkeys, fieldNumber: 2)
    }
    if !self.otherSignerPublicNonces.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.otherSignerPublicNonces, fieldNumber: 3)
    }
    if !self.tweaks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tweaks, fieldNumber: 4)
    }
    try { if let v = self._taprootTweak {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2SessionRequest, rhs: Signrpc_MuSig2SessionRequest) -> Bool {
    if lhs._keyLoc != rhs._keyLoc {return false}
    if lhs.allSignerPubkeys != rhs.allSignerPubkeys {return false}
    if lhs.otherSignerPublicNonces != rhs.otherSignerPublicNonces {return false}
    if lhs.tweaks != rhs.tweaks {return false}
    if lhs._taprootTweak != rhs._taprootTweak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2SessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2SessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "combined_key"),
    3: .standard(proto: "taproot_internal_key"),
    4: .standard(proto: "local_public_nonces"),
    5: .standard(proto: "have_all_nonces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.combinedKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.taprootInternalKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.localPublicNonces) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveAllNonces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.combinedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.combinedKey, fieldNumber: 2)
    }
    if !self.taprootInternalKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.taprootInternalKey, fieldNumber: 3)
    }
    if !self.localPublicNonces.isEmpty {
      try visitor.visitSingularBytesField(value: self.localPublicNonces, fieldNumber: 4)
    }
    if self.haveAllNonces != false {
      try visitor.visitSingularBoolField(value: self.haveAllNonces, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2SessionResponse, rhs: Signrpc_MuSig2SessionResponse) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.combinedKey != rhs.combinedKey {return false}
    if lhs.taprootInternalKey != rhs.taprootInternalKey {return false}
    if lhs.localPublicNonces != rhs.localPublicNonces {return false}
    if lhs.haveAllNonces != rhs.haveAllNonces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2RegisterNoncesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2RegisterNoncesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    3: .standard(proto: "other_signer_public_nonces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.otherSignerPublicNonces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.otherSignerPublicNonces.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.otherSignerPublicNonces, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2RegisterNoncesRequest, rhs: Signrpc_MuSig2RegisterNoncesRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.otherSignerPublicNonces != rhs.otherSignerPublicNonces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2RegisterNoncesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2RegisterNoncesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "have_all_nonces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.haveAllNonces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.haveAllNonces != false {
      try visitor.visitSingularBoolField(value: self.haveAllNonces, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2RegisterNoncesResponse, rhs: Signrpc_MuSig2RegisterNoncesResponse) -> Bool {
    if lhs.haveAllNonces != rhs.haveAllNonces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2SignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2SignRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "message_digest"),
    3: .same(proto: "cleanup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.messageDigest) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.cleanup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.messageDigest.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageDigest, fieldNumber: 2)
    }
    if self.cleanup != false {
      try visitor.visitSingularBoolField(value: self.cleanup, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2SignRequest, rhs: Signrpc_MuSig2SignRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.messageDigest != rhs.messageDigest {return false}
    if lhs.cleanup != rhs.cleanup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2SignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2SignResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_partial_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.localPartialSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localPartialSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.localPartialSignature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2SignResponse, rhs: Signrpc_MuSig2SignResponse) -> Bool {
    if lhs.localPartialSignature != rhs.localPartialSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2CombineSigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2CombineSigRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "other_partial_signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.otherPartialSignatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.otherPartialSignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.otherPartialSignatures, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2CombineSigRequest, rhs: Signrpc_MuSig2CombineSigRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.otherPartialSignatures != rhs.otherPartialSignatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2CombineSigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2CombineSigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "have_all_signatures"),
    2: .standard(proto: "final_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.haveAllSignatures) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.finalSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.haveAllSignatures != false {
      try visitor.visitSingularBoolField(value: self.haveAllSignatures, fieldNumber: 1)
    }
    if !self.finalSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.finalSignature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2CombineSigResponse, rhs: Signrpc_MuSig2CombineSigResponse) -> Bool {
    if lhs.haveAllSignatures != rhs.haveAllSignatures {return false}
    if lhs.finalSignature != rhs.finalSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2CleanupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2CleanupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2CleanupRequest, rhs: Signrpc_MuSig2CleanupRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_MuSig2CleanupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuSig2CleanupResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_MuSig2CleanupResponse, rhs: Signrpc_MuSig2CleanupResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
